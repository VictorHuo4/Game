<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Catch the Objects â€” Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html,body { height:100%; margin:0; display:flex; align-items:center; justify-content:center; background:#111; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; }
    .wrapper { text-align:center; }
    canvas { background: linear-gradient(#062038, #041826); display:block; border:4px solid #0af; border-radius:6px; box-shadow: 0 8px 30px rgba(0,0,0,0.6); }
    #ui { position:fixed; top:12px; left:12px; font-size:16px; }
    #hint { position:fixed; bottom:12px; left:12px; font-size:13px; opacity:0.9; }
    .small { font-size:13px; opacity:0.9; }
    @media (max-width:520px){
      canvas { width:92vw; height:auto; }
      #ui,#hint { left:8px; right:8px; }
    }
  </style>
</head>
<body>
  <div id="ui">Score: <span id="score">0</span> &nbsp; Lives: <span id="lives">3</span></div>
  <div id="hint">Controls: Left/Right arrows, A/D, move mouse, or drag/touch. Press Space or Tap to restart after Game Over.</div>
  <div class="wrapper">
    <canvas id="game" width="480" height="640"></canvas>
  </div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');

const W = canvas.width, H = canvas.height;

// Player (catcher)
const player = {
  w: 80,
  h: 18,
  x: (W - 80) / 2,
  y: H - 40,
  speed: 360, // px / second
  vx: 0
};

// Create falling object
function createObject() {
  return {
    x: Math.random() * (W - 28) + 14,
    y: -30,
    w: 24,
    h: 24,
    vy: 120 + Math.random() * 160,
    rot: Math.random() * Math.PI * 2,
    rotSpeed: (Math.random()-0.5) * 2.2,
    color: randomColor()
  };
}

function randomColor() {
  const colors = ['#ffd54f','#ff8a65','#4fc3f7','#a5d6a7','#ce93d8','#ffd180','#90caf9','#f48fb1'];
  return colors[Math.floor(Math.random()*colors.length)];
}

let objects = [];
let spawnTimer = 0;
let spawnInterval = 0.9; // seconds
let lastTime = 0;
let score = 0;
let lives = 3;
let gameOver = false;
let showStart = false; // if you want a start screen later

// input
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  // restart on Space when game over
  if (gameOver && e.code === 'Space') restart();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });

// mouse/touch input
let pointer = { active: false, x: player.x + player.w/2 };

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  pointer.active = true;
  pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);
});
canvas.addEventListener('mouseleave', () => pointer.active = false);

// pointer events (mouse/touch)
canvas.addEventListener('pointerdown', e => {
  const rect = canvas.getBoundingClientRect();
  pointer.active = true;
  pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);
  // if game over, a tap/click restarts
  if (gameOver) restart();
});
canvas.addEventListener('pointermove', e => {
  if (e.pressure === 0 && e.buttons === 0 && e.pointerType === 'touch') return; // avoid noisy events
  const rect = canvas.getBoundingClientRect();
  pointer.active = true;
  pointer.x = (e.clientX - rect.left) * (canvas.width / rect.width);
});
canvas.addEventListener('pointerup', () => { /* keep pointer.active true so you can still move by mouse */ });

// collision (AABB)
function collide(a, b) {
  return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
}

function update(dt) {
  if (gameOver) return;

  // speed up spawning as score grows
  spawnInterval = Math.max(0.32, 0.9 - score * 0.035);

  spawnTimer += dt;
  if (spawnTimer >= spawnInterval) {
    spawnTimer = 0;
    // spawn 1 or occasionally 2 objects
    objects.push(createObject());
    if (Math.random() < Math.min(0.25, score * 0.02)) objects.push(createObject());
  }

  // control: pointer has priority
  if (pointer.active) {
    const targetX = pointer.x - player.w/2;
    player.x += (targetX - player.x) * Math.min(1, 10 * dt); // smooth follow
  } else {
    player.vx = 0;
    if (keys['ArrowLeft'] || keys['KeyA']) player.vx = -player.speed;
    if (keys['ArrowRight'] || keys['KeyD']) player.vx = player.speed;
    player.x += player.vx * dt;
  }
  // clamp
  player.x = Math.max(0, Math.min(W - player.w, player.x));

  // update objects
  for (let i = objects.length - 1; i >= 0; i--) {
    const o = objects[i];
    o.vy += 6 * dt; // gravity-ish acceleration
    o.y += o.vy * dt;
    o.rot += o.rotSpeed * dt;

    // simple bounding box for the circular object
    const objBox = { x: o.x, y: o.y, w: o.w, h: o.h };
    const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };

    if (collide(objBox, playerBox)) {
      // caught
      objects.splice(i,1);
      score += 1;
      scoreEl.textContent = score;
      continue;
    }

    if (o.y > H + 40) {
      // missed
      objects.splice(i,1);
      lives -= 1;
      livesEl.textContent = lives;
      if (lives <= 0) {
        endGame();
        return;
      }
    }
  }
}

function endGame() {
  gameOver = true;
}

function restart() {
  score = 0;
  lives = 3;
  objects = [];
  spawnTimer = 0;
  spawnInterval = 0.9;
  player.x = (W - player.w) / 2;
  gameOver = false;
  scoreEl.textContent = score;
  livesEl.textContent = lives;
  lastTime = performance.now();
  requestAnimationFrame(loop);
}

function drawRoundedRect(x,y,w,h,r, color) {
  ctx.fillStyle = color;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  ctx.fill();
}

function draw() {
  // clear
  ctx.clearRect(0,0,W,H);

  // subtle background pattern
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = "#fff";
  for (let i=0;i<W;i+=28) ctx.fillRect(i,0,1,H);
  for (let j=0;j<H;j+=28) ctx.fillRect(0,j,W,1);
  ctx.globalAlpha = 1;

  // draw objects
  for (const o of objects) {
    ctx.save();
    ctx.translate(o.x + o.w/2, o.y + o.h/2);
    ctx.rotate(o.rot);
    // circle body
    ctx.fillStyle = o.color;
    ctx.beginPath();
    ctx.ellipse(0, 0, o.w/2, o.h/2, 0, 0, Math.PI*2);
    ctx.fill();
    // inner shine
    ctx.fillStyle = 'rgba(255,255,255,0.14)';
    ctx.beginPath();
    ctx.ellipse(-o.w*0.12, -o.h*0.18, o.w*0.22, o.h*0.14, 0, 0, Math.PI*2);
    ctx.fill();
    // rim
    ctx.strokeStyle = 'rgba(255,255,255,0.12)';
    ctx.stroke();
    ctx.restore();
  }

  // draw player (catcher)
  drawRoundedRect(player.x, player.y, player.w, player.h, 8, '#45aaf2');
  // highlight on catcher
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillRect(player.x, player.y, player.w, 6);

  // HUD panel (top-left small)
  ctx.fillStyle = 'rgba(0,0,0,0.28)';
  ctx.fillRect(6,6,150,34);
  ctx.fillStyle = '#dff';
  ctx.font = '14px system-ui, sans-serif';
  ctx.fillText('Score: ' + score, 12, 28);

  // Game Over overlay
  if (gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 36px system-ui, sans-serif';
    ctx.fillText('Game Over', W/2, H/2 - 10);
    ctx.font = '20px system-ui, sans-serif';
    ctx.fillText('Score: ' + score, W/2, H/2 + 24);
    ctx.font = '14px system-ui, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillText('Press Space or Tap to restart', W/2, H/2 + 56);
    ctx.textAlign = 'left';
  }
}

// main loop
function loop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = Math.min(0.05, (ts - lastTime) / 1000); // cap dt to avoid big jumps
  update(dt);
  draw();
  lastTime = ts;
  requestAnimationFrame(loop);
}

// start the game
lastTime = performance.now();
requestAnimationFrame(loop);

// expose restart to console for convenience
window.restartCatchGame = restart;
</script>
</body>
</html>